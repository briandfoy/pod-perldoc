#!perl
use v5.36;
use utf8;
use experimental qw(signatures);
use open qw(:std :utf8);

use Config qw(%Config);
use File::Basename;
use File::Path qw(make_path);
use File::Spec::Functions qw(catfile);
use Text::Diff;

$|++;

my $reference_perldoc;

run(@ARGV) unless caller;

sub run (@args) {
	state $dispatch = {
		got      => sub { got(@_) },
		expected => sub { expected(@_) },
		compare  => sub { compare() },
		help     => sub { help() },
		};

	my $mode = shift @args;
	$mode //= 'help';

	$reference_perldoc = $args[0] // 'perldoc';

	die join "\n\t", "Unknown mode <$mode>. Expected one of:\n",
		sort keys $dispatch->%* unless exists $dispatch->{$mode};

	$dispatch->{$mode}->(@args)
	}

sub compare {
	state $mode = 'compare';
	my_chdir();

	foreach my $name ( get_names() ) {
		my $expected_glob = catfile 'expected', $name, '*';
		my @expected_files = glob $expected_glob;

		foreach my $expected_file ( @expected_files ) {
			my $got_file = $expected_file =~ s/\Aexpected/got/r;
			compare_files( $got_file, $expected_file );
			}
		}
	}

sub compare_files ($got_file, $expected_file) {
	state $rc = require Text::Diff;
	state $r2 = require Term::ANSIColor;
	state $r3 = require Encode;

	my $ok = Term::ANSIColor::colored(['green'], "✔");
	my $not_ok = Term::ANSIColor::colored(['red'], "✘✘✘");

	if( ! -e $expected_file ) {
	 	say "$not_ok expected file <$expected_file> is missing";
		return;
		}
	elsif( ! -e $got_file ) {
		say "$not_ok got file <$got_file> is missing";
		return;
		}
	else {
		my $diff = Encode::decode(
			'UTF-8',
			Text::Diff::diff $got_file, $expected_file
			);
		my $status = length $diff ? $not_ok : $ok;
		printf "$status %s => %s\n", $got_file, $expected_file;
		if( length $diff ) {
			say $diff =~ s/^/    /gmr;
			}
		}
	}

sub expected {
	state $mode = 'expected';
	my_chdir();

	reference_perldoc();

	foreach my $name ( get_names() ) {
		make_path catfile( $mode, $name );
		convert_files( $name, $mode );
		}
	}

sub got {
	state $mode = 'got';
	my_chdir();

	$reference_perldoc = '../perldoc';
	$ENV{PERL5LIB} = '../lib';

	reference_perldoc();

	foreach my $name ( get_names() ) {
		make_path catfile( $mode, $name );
		convert_files( $name, $mode );
		}
	}

sub help {
	require Pod::Usage;
	Pod::Usage::pod2usage();
	}

sub convert_files {
	state @corpus = get_corpus();
	my( $name, $mode ) = @_;

	CORPUS: foreach my $original ( @corpus ) {
		my $output_file = basename($original) =~ s/\.pod\z/\.$name/r;
		my $output_path = catfile $mode, $name, $output_file;

		say STDERR "$original -> $output_path";

		my $output = `$^X $reference_perldoc -o $name $original`;
		open my $fh, '>:raw', $output_path or do {
			say STDERR "Could not open $output_path: $!";
			next CORPUS;
			};
		print {$fh} $output;
		close $fh;
		}
	}

sub get_corpus {
	glob 'corpus/*.pod corpus/**/*.pod'
	}

sub get_names {
	map { basename($_) } glob "expected/*";
	}

sub my_chdir {
	require FindBin;
	chdir $FindBin::Bin or die "Could not change to <$FindBin::Bin>: $!";
	}

sub reference_perldoc {
	print "Reference perldoc:\n\t";
	system {$reference_perldoc} $reference_perldoc, '-V';
	print "\n";
	}

=encoding utf8

=head1 NAME

corpus-util.pl -

=head1 SYNOPSIS

Output the docs:

	% corpus-util.pl help

Recreate the expected output using the first perldoc in the path:

	% corpus-util.pl expected

Recreate the expected output using the specified perldoc:

	% corpus-util.pl expected /full/path/to/reference/perldoc

Recreate the expected output using the specified perldoc and perl:

	% corpus-util.pl expected /full/path/to/reference/perldoc

Generate the output using the repo perldoc

	% corpus-util.pl got

Compare the stuff generated by C<got> to the stuff generated by C<expected>

	% corpus-util.pl compare

=head1 DESCRIPTION

=cut
